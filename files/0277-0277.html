<HTML>

<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0276-0276.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0278-0279.html">Next</A></CENTER></P>



<A NAME="PAGENUM-277"><P>Page 277</P></A>


<P>
dangerous, since short misspellings may be missed. If you use this option a lot, you should probably make a last pass
without it before you publish your document, to protect yourself against errors.
</P>

<P>The _T option is used to specify a default formatter type for use in generating string characters. This switch overrides
the default type determined from the filename. The
type argument may be either one of the unique names defined in
the language affix file (such as nroff) or a file suffix including the dot (for example,
.tex). If no _T option appears and no type can be determined from the filename, the default string character type declared in the language affix file will be used.
</P>

<P>The _l or list option to ispell is used to produce a list of misspelled words from the standard input.
</P>

<P>The _a option is intended to be used from other programs through a pipe. In this mode,
ispell prints a one-line version identification message, and then begins reading lines of input. For each input line, a single line is written to the
standard output for each word checked for spelling on the line. If the word was found in the main dictionary, or your
personal dictionary, then the line contains only a
*. If the word was found through affix removal, then the line contains a
+, a space, and the root word. If the word was found through compound formation (concatenation of two words, controlled by the
_C option), then the line contains only a _.
</P>

<P>If the word is not in the dictionary, but there are near misses, then the line contains an
&amp;, a space, the misspelled word, a space, the number of near misses, the number of characters between the beginning of the line and the beginning of
the misspelled word, a colon, another space, and a list of the near misses separated by commas and spaces. Following the
near misses (and identified only by the count of near misses), if the word could be formed by adding (illegal) affixes to a
known root, is a list of suggested derivations, again separated by commas and spaces. If there are no near misses at all, the line
format is the same, except that the &amp; is replaced by
? (and the near-miss count is always zero). The suggested derivations
following the near misses are in the form:
</P>

<!-- CODE SNIP //-->
<PRE>
[prefix+] root [-prefix] [-suffix] [+suffix]
</PRE>
<!-- END CODE SNIP //-->

<P>(for example, &quot;re+fry-y+ies&quot; to get &quot;refries&quot;) where each optional
pfx and sfx is a string. Also, each near miss or guess
is capitalized the same as the input word unless such capitalization is illegal; in the latter case each near miss is
capitalized correctly according to the dictionary.
</P>

<P>Finally, if the word does not appear in the dictionary, and there are no near misses, then the line contains a
#, a space, the misspelled word, a space, and the character offset from the beginning of the line. Each sentence of text input is
terminated with an additional blank line, indicating that
ispell has completed processing the input line.
</P>

<P>These output lines can be summarized as follows:
</P>

<TABLE>

<TR><TD>
OK:
</TD><TD>
*
</TD></TR><TR><TD>
Root:
</TD><TD>
+ &lt;root&gt;
</TD></TR><TR><TD>
Compound:
</TD><TD>
_
</TD></TR><TR><TD>
Miss:
</TD><TD>
&amp; &lt;original&gt;&lt;count&gt;&lt;offset&gt;: &lt;miss&gt;, &lt;miss&gt;, ..., &lt;guess&gt;, ...
</TD></TR><TR><TD>
Guess:
</TD><TD>
? &lt;original&gt; 0 &lt;offset&gt;: &lt;guess&gt;, &lt;guess&gt;, ...
</TD></TR><TR><TD>
None:
</TD><TD>
# &lt;original&gt; &lt;offset&gt;
</TD></TR></TABLE>

<P>For example, a dummy dictionary containing the words
fray, Frey, fry, and refried might produce the following response
to the command echo `frqy refries | ispell -a -m -d ./test.hash:
</P>

<!-- CODE SNIP //-->
<PRE>
(#) International Ispell Version 3.0.05 (beta), 08/10/91
&amp; frqy 3 0: fray, Frey, fry
&amp; refries 1 5: refried, re+fry-y+ies
</PRE>
<!-- END CODE SNIP //-->

<P>This mode is also suitable for interactive use when you want to figure out the spelling of a single word.
</P>

<P>The _A option works just like _a, except that if a line begins with the string
&quot;&amp;Include File&amp;&quot;, the rest of the line is taken
as the name of a file to read for further words. Input returns to the original file when the
include file is exhausted. Inclusion may be nested up to five deep. The key string may be changed with the ENVIRONMENT variable
INCLUDE_STRING (the ampersands, if any, must be included).
</P>



<P><CENTER>
<a href="0276-0276.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0278-0279.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>