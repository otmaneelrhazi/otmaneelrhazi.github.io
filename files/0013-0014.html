<HTML>
<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0012-0012.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0015-0016.html">Next</A></CENTER></P>



<A NAME="PAGENUM-13"><P>Page 13</P></A>

<P>
An OR list has the form
</P>

<!-- CODE SNIP //-->
<PRE>
command command2
</PRE>
<!-- END CODE SNIP //-->


<P>command2 is executed if, and only if, command returns a non_zero exit status. The return status of
AND and OR lists is the exit status of the last command executed in the list.
</P>

<B>
<P>COMPOUND COMMANDS</P>
</B>


<P>A compound command is one of the following:
</P>

<!-- CODE SNIP //-->
<PRE>
(list)
</PRE>
<!-- END CODE SNIP //-->


<P>list is executed in a subshell. Variable assignments and built-in commands that affect the shell's environment do not
remain in effect after the command completes. The return status is the exit status of
list.
</P>

<!-- CODE SNIP //-->
<PRE>
{ list; }
</PRE>
<!-- END CODE SNIP //-->


<P>list is simply executed in the current shell environment. This is known as a group command. The return status is the
exit status of list.
</P>

<!-- CODE SNIP //-->
<PRE>
for name [ in word;] do list ; done
</PRE>
<!-- END CODE SNIP //-->

<P>The list of words following in is expanded, generating a list of items. The variable name is set to each element of this list
in turn, and list is executed each time. If the in word is omitted, the
for command executes list once for each positional parameter that is set. (See &quot;Parameters,&quot; later in this manual page.)
</P>

<!-- CODE SNIP //-->
<PRE>
select name [ in word;] do list ; done
</PRE>
<!-- END CODE SNIP //-->


<P>The list of words following in is expanded, generating a list of items. The set of expanded words is printed on the
standard error, each preceded by a number. If the
in word is omitted, the positional parameters are printed. (See &quot;Parameters.&quot;)
The PS3 prompt is then displayed and a line read from the standard input. If the line consists of the number corresponding
to one of the displayed words, then the value of name is set to that word. If the line is empty, the words and prompt
are displayed again. If EOF is read, the command completes. Any other value read causes name to be set to null. The line read
is saved in the variable REPLY. The list is executed after each selection until a
break or return command is executed. The exit status of
select is the exit status of the last command executed in
list, or zero if no commands were executed.
</P>

<!-- CODE SNIP //-->
<PRE>
case word in [ pattern [ | pattern ]
</PRE>
<!-- END CODE SNIP //-->


<P>A case command first expands word, and tries to match it against each
pattern in turn, using the same matching rules as
for pathname expansion. (See &quot;Pathname Expansion,&quot; later in this manual page.) When a match is found, the corresponding
list is executed. After the first match, no subsequent matches are attempted. The exit status is
zero if no patterns are matches. Otherwise, it is the exit status of the last command executed in
list.
</P>

<!-- CODE SNIP //-->
<PRE>
if list then list [ elif list then list ] ... [ else list ] fi
</PRE>
<!-- END CODE SNIP //-->


<P>The if list is executed. If its exit status is zero, the
then list is executed. Otherwise, each elif list is executed in turn, and if
its exit status is zero, the corresponding then list is executed and the command completes. Otherwise, the
else list is executed, if present. The exit status is the exit status of the last command executed, or
zero if no condition tested True.
</P>

<!-- CODE SNIP //-->
<PRE>
while list do list done

until list do list done
</PRE>
<!-- END CODE SNIP //-->


<P>The while command continuously executes the do list as long as the last command in
list returns an exit status of zero. The until command is identical to the
while command, except that the test is negated; the
do list is executed as long as the last command in
list returns a non_zero exit status. The exit status of the
while and until commands is the exit status of the
last do list command executed, or zero if none was executed.
</P>

<!-- CODE SNIP //-->
<PRE>
[ function ] name () { list; }
</PRE>
<!-- END CODE SNIP //-->

<P>This defines a function named name. The body of the function is the list of commands between { and }. This list is
executed whenever name is specified as the name of a simple command. The exit status of a function is the exit status of the
last command executed in the body. (See &quot;Functions,&quot; later in this manual page.)
</P>

<A NAME="PAGENUM-14"><P>Page 14</P></A>


<B>
<P>COMMENTS</P>
</B>


<P>In a noninteractive shell, or an interactive shell in which the
-o interactive_comments option to the set builtin is enabled,
a word beginning with # causes that word and all remaining characters on that line to be ignored. An interactive shell
without the -o interactive_comments option enabled does not allow comments.
</P>

<B>
<P>QUOTING</P>
</B>


<P>Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to
disable special treatment for special characters, to prevent reserved words from being recognized as such, and to prevent
parameter expansion.
</P>

<P>Each of the meta characters listed earlier under &quot;Definitions&quot; has special meaning to the shell and must be quoted if it is
to represent itself. There are three quoting mechanisms: the escape character, single quotes, and double quotes.
</P>

<P>A nonquoted backslash (\) is the escape character. It preserves the literal value of the next character that follows, with
the exception of &lt;newline&gt;.If a
\&lt;newline&gt; pair appears, and the backslash is not quoted, the
\&lt;newline&gt; is treated as a line continuation; that is, it is effectively ignored.
</P>

<P>Enclosing characters in single quotes preserves the literal value of each character within the quotes. A single quote may
not occur between single quotes, even when preceded by a backslash.
</P>

<P>Enclosing characters in double quotes preserves the literal value of all characters within the quotes, with the exception of
$, `, and \. The characters $ and ` retain their special meaning within double quotes. The backslash retains its special
meaning only when followed by one of the following characters:
$, `, &quot;, \, or &lt;newline&gt;. A double quote may be quoted within
double quotes by preceding it with a backslash.
</P>

<P>The special parameters * and @ have special meaning when in double quotes. (See &quot;Parameters,&quot; next.)
</P>

<B>
<P>PARAMETERS</P>
</B>


<P>A parameter is an entity that stores values, somewhat like a variable in a conventional programming language. It can be
a name, a number, or one of the special characters listed under &quot;Special Parameters,&quot; following. For the shell's purposes,
a variable is a parameter denoted by a name.
</P>

<P>A parameter is set if it has been assigned a value. The null string is a valid value. Once a variable is set, it may be unset
only by using the unset built-in command. (See &quot;Shell Built-in Commands,&quot; later in this manual page.)
</P>

<P>A variable may be assigned to by a statement of the form:
</P>

<!-- CODE SNIP //-->
<PRE>
name=[value]
</PRE>
<!-- END CODE SNIP //-->


<P>If value is not given, the variable is assigned the null string. All values undergo tilde expansion, parameter and
variable expansion, command substitution, arithmetic expansion, and quote removal. If the variable has its
_i attribute set (see declare in &quot;Shell Built-in Commands&quot;) then
value is subject to arithmetic expansion even if
the $[...] syntax does not appear. Word splitting is not performed, with the exception of
&quot;$@&quot;, as explained under &quot;Special Parameters.&quot;
Pathname expansion is not performed.
</P>

<B>
<P>POSITIONAL PARAMETERS</P>
</B>


<P>A positional parameter is a parameter denoted by one or more digits, other than the single digit 0. Positional parameters
are assigned from the shell's arguments when it is invoked, and may be reassigned using the
set built-in command. Positional parameters may not be assigned to with assignment statements. The positional parameters are temporarily replaced when
a shell function is executed. (See &quot;Functions,&quot; later in this manual page.)
<P>When a positional parameter consisting of more than a single digit is expanded, it must be enclosed in braces.
(See &quot;Expansion,&quot; later in this manual page.)
</P>

<B>
<P>SPECIAL PARAMETERS</P>
</B>

<P>The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed.
</P>





<P><CENTER>
<a href="0012-0012.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0015-0016.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>