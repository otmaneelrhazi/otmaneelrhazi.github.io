<HTML>

<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0162-0164.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0167-0168.html">Next</A></CENTER></P>



<A NAME="PAGENUM-165"><P>Page 165</P></A>


<P>When a string must be converted to a number, the conversion is accomplished using
atof(3). A number is converted to a string by using the value of
CONVFMT as a format string for sprintf(3), with the numeric value of the variable as the
argument. However, even though all numbers in awk are floating-point, integral values are
always converted as integers. Thus, given this:
</P>

<!-- CODE SNIP //-->
<PRE>
CONVFMT = &quot;%2.2f&quot;
a =12
b =a&quot;&quot;
</PRE>
<!-- END CODE SNIP //-->

<P>the variable b has a string value of 12 and not
12.00.
</P>

<P>gawk performs comparisons as follows: If two variables are numeric, they are compared numerically. If one value is
numeric and the other has a string value that is a &quot;numeric string,&quot; then comparisons are also done numerically. Otherwise,
the numeric value is converted to a string and a string comparison is performed. Two strings are compared, of course, as
strings. According to the standard, even if two strings are numeric strings, a numeric comparison is performed. However, this
is clearly incorrect, and gawk does not do this.
</P>

<P>Uninitialized variables have the numeric value
0 and the string value &quot;&quot; (the null, or empty, string).
</P>

<P><B>
PATTERNS AND ACTIONS
</B></P>

<P>awk is a line-oriented language. The pattern comes first, and then the action. Action
statements are enclosed in and .BR. Either the pattern may be missing, or the action may be missing, but, of course, not both. If the pattern is missing, the
action will be executed for every single line of input. A missing action is equivalent to
</P>

<!-- CODE SNIP //-->
<PRE>
{ print }
</PRE>
<!-- END CODE SNIP //-->

<P>which prints the entire line.
</P>

<P>Comments begin with the # character, and continue until the end of the line. Blank lines may be used to separate
statements. Normally, a statement ends with a newline, however, this is not the case for lines ending in a
,, {, ?, :, &amp;&amp;, or ||. Lines ending in do or
else also have their statements automatically continued on the following line. In other cases, a line can
be continued by ending it with a \, in which case the newline will be ignored.
</P>

<P>Multiple statements may be put on one line by separating them with a semicolon. This applies to both the statements
within the action part of a pattern-action pair (the usual case), and to the pattern-action statements themselves.
</P>

<P><B>
PATTERNS
</B></P>

<P>awk patterns may be one of the following:
</P>

<!-- CODE //-->
<PRE>
BEGIN
END
/regular expression/
relational expression
pattern &amp;&amp; pattern
pattern jj pattern
pattern ? pattern : pattern
(pattern)
! pattern
pattern1, pattern2
</PRE>
<!-- END CODE //-->

<P>BEGIN and END are two special kinds of patterns that are not tested against the input. The action parts of all
BEGIN patterns are merged as if all the statements had been written in a single
BEGIN block. They are executed before any of the input is
read. Similarly, all the END blocks are merged, and executed when all the input is exhausted (or when an
exit statement is executed). BEGIN and END patterns cannot be combined with other patterns in pattern expressions.
BEGIN and END patterns cannot have missing action parts.
</P>

<P>For /regular expression/ patterns, the associated statement is executed for each input line that matches the
regular expression. Regular expressions are the same as those in
egrep(1), and are summarized as follows:
</P>

<A NAME="PAGENUM-166"><P>Page 166</P></A>


<P>A relational expression may use any of the operators defined later in the section on actions. These generally test
whether certain fields match certain regular expressions.
</P>

<P>The &amp;&amp;, ||, and ! operators are logical
AND, logical OR, and logical NOT, respectively, as in C. They do short-circuit
evaluation, also as in C, and are used for combining more primitive pattern expressions. As in most languages, parentheses may be
used to change the order of evaluation.
</P>

<P>The ?: operator is like the same operator in C. If the first pattern is true, then the pattern used for testing is the
second pattern; otherwise, it is the third. Only one of the second and third patterns is evaluated.
</P>

<P>The pattern1, pattern2 form of an expression is called a
range pattern. It matches all input records starting with a line
that matches pattern1, and continuing until a record that matches
pattern2, inclusive. It does not combine with any other sort
of pattern expression.
</P>

<P><B>
REGULAR EXPRESSIONS
</B></P>

<P>Regular expressions are the extended kind found in
egrep. They are composed of characters as follows:
</P>

<TABLE>

<TR><TD>
c
</TD><TD>
Matches the non-meta-character c.
</TD></TR><TR><TD>
\c
</TD><TD>
Matches the literal character c.
</TD></TR><TR><TD>
.
</TD><TD>
Matches any character except newline.
</TD></TR><TR><TD>
^
</TD><TD>
Matches the beginning of a line or a string.
</TD></TR><TR><TD>
$
</TD><TD>
Matches the end of a line or a string.
</TD></TR><TR><TD>
[abc...]
</TD><TD>
Character class, matches any of the characters
abc....
</TD></TR><TR><TD>
[^abc...]
</TD><TD>
Negated character class, matches any character except
abc... and newline.
</TD></TR><TR><TD>
r1|r2
</TD><TD>
Alternation: matches either r1 or r2.
</TD></TR><TR><TD>
r1r2
</TD><TD>
Concatenation: matches r1, and then r2.
</TD></TR><TR><TD>
r+
</TD><TD>
Matches one or more rs.
</TD></TR><TR><TD>
r*
</TD><TD>
Matches zero or more rs.
</TD></TR><TR><TD>
r?
</TD><TD>
Matches zero or one rs.
</TD></TR><TR><TD>
(r)
</TD><TD>
Grouping: matches r.
</TD></TR></TABLE>

<P>The escape sequences that are valid in string constants are also legal in regular expressions.
</P>

<P><B>
ACTIONS
</B></P>

<P>Action statements are enclosed in braces, { and
}. Action statements consist of the usual assignment, conditional, and
looping statements found in most languages. The operators, control statements, and input/output statements available are
patterned after those in C.
</P>

<P><B>
OPERATORS
</B></P>

<P>The operators in awk, in order of increasing precedence, are
</P>

<TABLE>

<TR><TD>
=+=_=
*= /= %= ^=
</TD><TD>
Assignment. Both absolute assignment
(var = value) and operator-assignment (the other forms) are
supported.
</TD></TR><TR><TD>
?:
</TD><TD>
The C conditional expression. This has the form
expr1 ? expr2 : expr3 .If expr1 is true, the value of
the expression is expr2; otherwise, it is expr3. Only one of
expr2 and expr3 is evaluated.
</TD></TR><TR><TD>
||
</TD><TD>
Logical OR.
</TD></TR><TR><TD>
&amp;&amp;
</TD><TD>
Logical AND.
</TD></TR><TR><TD>
~!~
</TD><TD>
Regular expression match, negated match. NOTE: Do not use a constant regular expression
(/foo/) to the left of a ~ or !~. Only use one on the right side. The expression
/foo/ ~ exp has the same meaning as (($0 ~ /foo/) ~
exp). This is usually not what was intended.
</TD></TR><TR><TD>
&lt; &gt;, &lt;=&gt;=
</TD><TD>
The regular relational operators.
</TD></TR><TR><TD>
blank
</TD><TD>
String concatenation.
</TD></TR><TR><TD>
+_
</TD><TD>
Addition and subtraction.
</TD></TR></TABLE>



<P><CENTER>
<a href="0162-0164.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0167-0168.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>