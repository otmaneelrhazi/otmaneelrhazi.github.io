<HTML>
<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0224-0224.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0227-0231.html">Next</A></CENTER></P>



<A NAME="PAGENUM-225"><P>Page 225</P></A>


<TABLE>

<TR><TD>
_num
</TD><TD>
Matches will be printed with num lines of leading and trailing context. However,
grep will never print any given line more than once.
</TD></TR><TR><TD>
_A num
</TD><TD>
Print num lines of trailing context after matching lines.
</TD></TR><TR><TD>
_B num
</TD><TD>
Print num lines of leading context before matching lines.
</TD></TR><TR><TD>
_C
</TD><TD>
Equivalent to _2.
</TD></TR><TR><TD>
_V
</TD><TD>
Print the version number of grep to standard error. This version number should be included in all
bug reports.
</TD></TR><TR><TD>
_b
</TD><TD>
Print the byte offset within the input file before each line of output.
</TD></TR><TR><TD>
_c
</TD><TD>
Suppress normal output; instead print a count of matching lines for each input file. With the
_v option, count nonmatching lines.
</TD></TR><TR><TD>
_e pattern
</TD><TD>
Use pattern as the pattern; useful to protect patterns beginning with
_.
</TD></TR><TR><TD>
_f file
</TD><TD>
Obtain the pattern from file.
</TD></TR><TR><TD>
_h
</TD><TD>
Suppress the prefixing of filenames on output when multiple files are searched.
</TD></TR><TR><TD>
_i
</TD><TD>
Ignore case distinctions in both the
pattern and the input files.
</TD></TR><TR><TD>
_L
</TD><TD>
Suppress normal output; instead print the name of each input file from which no output
would normally have been printed.
</TD></TR><TR><TD>
_l
</TD><TD>
Suppress normal output; instead print the name of each input file from which output would
normally have been printed.
</TD></TR><TR><TD>
_n
</TD><TD>
Prefix each line of output with the line number within its input file.
</TD></TR><TR><TD>
_q
</TD><TD>
Quiet; suppress normal output.
</TD></TR><TR><TD>
_s
</TD><TD>
Suppress error messages about nonexistent or unreadable files.
</TD></TR><TR><TD>
_v
</TD><TD>
Invert the sense of matching, to select nonmatching lines.
</TD></TR><TR><TD>
_w
</TD><TD>
Select only those lines containing matches that form whole words. The test is that the
matching substring must either be at the beginning of the line, or preceded by a nonword constituent
character. Similarly, it must be either at the end of the line or followed by a nonword-constituent
character. Word-constituent characters are letters, digits, and the underscore.
</TD></TR><TR><TD>
_x
</TD><TD>
Select only those matches that exactly match the whole line.
</TD></TR></TABLE>


<P><B>
REGULAR EXPRESSIONS
</B>
</P>

<P>A regular expression is a pattern that describes a set of strings. Regular expressions are constructed analogously to
arithmetic expressions, by using various operators to combine smaller expressions.
</P>

<P>grep understands two different versions of regular expression syntax:
basic and extended. In GNU\grep, there is no
difference in available functionality using either syntax. In other implementations, basic regular expressions are less powerful.
The following description applies to extended regular expressions; differences for basic regular expressions are
summarized afterwards.
</P>

<P>The fundamental building blocks are the regular expressions that match a single character. Most characters, including
all letters and digits, are regular expressions that match themselves. Any meta character with special meaning may be quoted
by preceding it with a backslash.
<P>A list of characters enclosed by [ and ] matches any single character in that list; if the first character of the list is the caret
(^) then it matches any character not in the list. For example, the regular expression
[0123456789] matches any single digit. A range of ASCII characters may be specified by giving the first and last characters, separated by a hyphen. Finally,
certain named classes of characters are predefined. Their names are self-explanatory, and they are
[:alnum:], [:alpha:], [:cntrl:], [:digit:],
[:graph:], [:lower:], [:print:], [:punct:],
[:space:], [:upper:], and [:xdigit:]. For example,
[[:alnum:]] means [0-9A-Za- z], except the latter form is dependent upon the ASCII character encoding, whereas the former is
portable. (Note that the brackets in these class names are part of the symbolic names, and must be included in addition to the
brackets delimiting the bracket list.) Most meta characters lose their special meaning inside lists. To include a literal
], place it first in the list. Similarly, to include a literal
^, place it anywhere but first. Finally, to include a literal
-_, place it last.
</P>

<P>The period matches any single character. The symbol
\w is a synonym for [[:alnum:]] and \W is a synonym for
[^[:alnum]].
</P>

<A NAME="PAGENUM-226"><P>Page 226</P></A>


<P>The caret and the dollar sign are meta characters that respectively match the empty string at the beginning and end of a
line. The symbols \&lt; and \&gt;, respectively, match the empty string at the beginning and end of a word. The symbol
\b matches the empty string at the edge of a word, and
\B matches the empty string provided it's not at the edge of a word.
</P>

<P>A regular expression matching a single character may be followed by one of several repetition operators:
</P>

<C>
?
<C>
The preceding item is optional and matched at most once.
<C>
*
<C>
The preceding item will be matched zero or more times.
<C>
+
<C>
The preceding item will be matched one or more times.
<C>
n
<C>
The preceding item is matched exactly n times.
<C>
n,
<C>
The preceding item is matched n or more times.
<C>
,m
<C>
The preceding item is optional and is matched at most
m times.
<C>
n,m
<C>
The preceding item is matched at least
n times, but not more than m times.
</P>

<P>Two regular expressions may be concatenated; the resulting regular expression matches any string formed by
concatenating two substrings that respectively match the concatenated subexpressions.
</P>
<P>Two regular expressions may be joined by the infix operator |; the resulting regular expression matches any string
matching either subexpression.
</P>
<P>Repetition takes precedence over concatenation, which in turn takes precedence over alternation. A whole subexpression
may be enclosed in parentheses to override these precedence rules.
</P>
<P>The back reference \n, where n is a single digit, matches the substring previously matched by the
nth parenthesized subexpression of the regular expression.
</P>
<P>In basic regular expressions, the meta characters
|, (, and ) lose their special meaning; instead use the backslashed
versions \?, \+, \f, \j, \(, and \).
</P>
<P>In egrep, the meta character { loses its special meaning; instead use
\{.
</P>

<P><B>
DIAGNOSTICS
</B>
</P>


<P>Normally, exit status is 0 if matches were found, and
1 if no matches were found. (The .B _v option inverts the sense of
the exit status.) Exit status is 2 if there were syntax errors in the pattern, inaccessible input files, or other system errors.
</P>

<P><B>
BUGS
</B>
</P>



<P>E-mail bug reports to bug-gnu-utils@prep.ai.mit.edu. Be sure to include the word
grep somewhere in the &quot;Subject:&quot; field.
</P>

<P>Large repetition counts in the m ,n construct may cause
grep to use lots of memory. In addition, certain other obscure
regular expressions require exponential time and space, and may cause
grep to run out of memory.
</P>

<P>Back references are very slow, and may require exponential time.
</P>

<P>GNU Project, 10 September 1992
</P>

<H3><A NAME="ch01_ 97">
grephistory
</A></H3>

<P>grephistory&#151;Display filenames from Usenet history file
</P>

<P><B>
SINOPSIS
</B>
</P>


<!-- CODE SNIP //-->
<PRE>
grephistory [ _f filename ][_e ][_n ][_q ][_l ][_i ][_s ][messageid ]
</PRE>
<!-- END CODE SNIP //-->

<P><B>
DESCRIPTION
</B>
</P>



<P>grephistory queries the dbz(3) index into the
history(5) file for an article having a specified Message ID.
</P>

<P>If messageid cannot be found in the database, the program prints &quot;Not found&quot; and exits with a nonzero status. If
messageid is in the database, the program prints the pathname and exits successfully. If no pathname exists, the program will print
/dev/
</P>



<P><CENTER>
<a href="0224-0224.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0227-0231.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>