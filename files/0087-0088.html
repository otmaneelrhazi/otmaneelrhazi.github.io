<HTML>

<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE></TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0086-0086.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0089-0090.html">Next</A></CENTER></P>











<A NAME="PAGENUM-87"><P>Page 87</P></A>

<H3><A NAME="ch01_ 46">
ctags
</A></H3>

<!-- CODE SNIP //-->
<PRE>
ctags&#151;Generates tags and (optionally) refs files
</PRE>
<!-- END CODE SNIP //-->


<P><B>
SYNOPSIS
</B></P>

<!-- CODE SNIP //-->
<PRE>
ctags [-BSstvraT] filesnames...
</PRE>
<!-- END CODE SNIP //-->


<P><B>
DESCRIPTION
</B></P>

<P>ctags generates the tags and refs files from a group of C source files. The
tags file is used by the elvis :tag command,
control-] command, and -t option. The refs file is sometimes used by the
ref(1) program.
</P>

<P>Each C source file is scanned for #define statements and global function definitions. The name of the macro or
function becomes the name of a tag. For each tag, a line is added to the
tags file that contains the following:
</P>

<UL>
<LI>          The name of the tag
<LI>          A tab character
<LI>          The name of the file containing the tag
<LI>          A tab character
<LI>          A way to find the particular line within the file
</UL>


<P>The filenames list will typically be the names of all C source files in the current directory,
like this:
</P>

<!-- CODE SNIP //-->
<PRE>
$ ctags -stv *.[ch]
</PRE>
<!-- END CODE SNIP //-->

<P><B>
OPTIONS
</B></P>

<TABLE>

<TR><TD>
-B
</TD><TD>
Normally, ctags encloses regular expressions in slashes
(/regexp/), which causes elvis to search from the top of the file. The
-B flag causes ctags to enclose the regular expressions in question marks
(?regexp?) so elvis will search backward from the bottom of the file. This rarely matters.
</TD></TR><TR><TD>
-t
</TD><TD>
Include typedefs. A tag will be generated for each user-defined type. Also tags will be generated for
struct and enum names. Types are considered to be global if they are defined in a header file, and static if they
are defined in a C source file.
</TD></TR><TR><TD>
-v
</TD><TD>
Include variable declarations. A tag will be generated for each variable, except for those that are
declared inside the body of a function.
</TD></TR><TR><TD>
-s
</TD><TD>
Include static tags. ctags will normally put global tags in the
tags file, and silently ignore the static tags. This flag causes both global and static tags to be added. The name of a static tag is generated by
prefixing the name of the declared item with the name of the file where it is defined, with a colon in between.
For example, static foo(){} in bar.c results in a tag named
bar.c:foo.
</TD></TR><TR><TD>
-S
</TD><TD>
Include static tags, but make them look like global tags. Most tags-aware programs don't like
the filename:tagname tags produced by the -s flag, so
-S was added as an alternative. If elvis and ref are
the only programs that read the tags file, then you don't need
-S; otherwise, you do.
</TD></TR><TR><TD>
-r
</TD><TD>
This causes ctags to generate both tags and
refs. Without -r, it would only generate tags.
</TD></TR><TR><TD>
-a
</TD><TD>
Append to tags, and maybe refs. Normally,
ctags overwrites these files each time it is invoked. This flag
is useful when you have too many files in the current directory for you to list them on a single
command line; it allows you to split the arguments among several invocations.
</TD></TR><TR><TD>
-T
</TD><TD>
This flag isn't available on all systems. UNIX has it, but most others don't. The
-T flag prevents ctags from generating a tags file. This is useful when you want to generate a
refs without changing tags.
</TD></TR></TABLE>

<P><B>
FILES
</B></P>

<TABLE>

<TR><TD>
tags
</TD><TD>
A cross-reference that lists each tag name, the name of the source file that contains it, and a way to locate
a particular line in the source file.
</TD></TR><TR><TD>
refs
</TD><TD>
The refs file contains the definitions for each tag in the
tags file, and very little else. This file can be useful, for example, when licensing restrictions prevent you from making the source code to the
standard C library readable by everybody, but you still want everybody to know what arguments the
library functions need.
</TD></TR></TABLE>


<A NAME="PAGENUM-88"><P>Page 88</P></A>


<P><B>
BUGS
</B></P>

<P>ctags is sensitive to indenting and line breaks. Consequently, it might not discover all of the tags in a file that is formatted
in an unusual way.
</P>

<P><B>
SEE ALSO
</B></P>

<!-- CODE SNIP //-->
<PRE>
elvis(1), refs(1)
</PRE>
<!-- END CODE SNIP //-->

<P><B>
AUTHOR
</B></P>

<P>Steve Kirkendall (kirkenda@cs.pdx.edu)
</P>


<H3><A NAME="ch01_ 47">
cu
</A></H3>

<P>cu&#151;Call up another system</P>


<P><B>
SYNOPSIS
</B></P>

<!-- CODE SNIP //-->
<PRE>
cu [ options ] [ system | phone | &quot;dir&quot; ]
</PRE>
<!-- END CODE SNIP //-->

<P><B>
DESCRIPTION
</B></P>


<P>The cu command is used to call up another system and act as a dial in terminal. It can also do simple file transfers with
no error checking.
</P>

<P>cu takes a single argument, besides the options. If the argument is the string
dir, cu will make a direct connection to the port. This may only be used by users with write access to the port, as it permits reprogramming the modem.
</P>

<P>Otherwise, if the argument begins with a digit, it is taken to be a phone number to call. Otherwise, it is taken to be the
name of a system to call. The _z or &#151;system option may be used to name a system beginning with a digit, and the
_c or &#151;phone option may be used to name a phone number that does not begin with a digit.
</P>

<P>cu locates a port to use in the UUCP configuration files. If a simple system name is given, it will select a port appropriate
for that system. The _p, &#151;port, _l,
&#151;line, _s, and &#151;speed options may be used to control the port selection.
</P>

<P>When a connection is made to the remote system,
cu forks into two processes. One reads from the port and writes to
the terminal, while the other reads from the terminal and writes to the port.
</P>

<P>cu provides several commands that may be used during the conversation. The commands all begin with an escape
character, initially ~ (tilde). The escape character is only recognized at the beginning of a line. To send an escape character to
the remote system at the start of a line, it must be entered twice. All commands are either a single character or a word
beginning with % (percent sign).
</P>

<P>cu recognizes the following commands:</P>


<TABLE>

<TR><TD>
 ~.
</TD><TD>
Terminate the conversation.
</TD></TR><TR><TD>
~! command
</TD><TD>
Run command in a shell. If command is empty, starts up a shell.
</TD></TR><TR><TD>
~$ command
</TD><TD>
Run command, sending the standard output to the remote system.
</TD></TR><TR><TD>
~| command
</TD><TD>
Run command, taking the standard input from the remote system.
</TD></TR><TR><TD>
~+ command
</TD><TD>
Run command, taking the standard input from the remote system and sending the
standard output to the remote system.
</TD></TR><TR><TD>
~#, ~%break
</TD><TD>
Send a break signal, if possible.
</TD></TR><TR><TD>
~c directory, ~%cd directory
</TD><TD>
Change the local directory.
</TD></TR><TR><TD>
~&gt; file
</TD><TD>
Send a file to the remote system. This just dumps the file over the communication line. It
is assumed that the remote system is expecting it.
</TD></TR><TR><TD>
~&lt;
</TD><TD>
Receive a file from the remote system. This prompts for the local filename and for
the remote command to execute to begin the file transfer. It continues accepting data until
the contents of the eofread variable are seen.
</TD></TR></TABLE>



<P><CENTER>
<a href="0086-0086.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0089-0090.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>