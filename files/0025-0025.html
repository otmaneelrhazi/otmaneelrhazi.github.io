<HTML>
<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0023-0024.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0026-0027.html">Next</A></CENTER></P>



<A NAME="PAGENUM-25"><P>Page 25</P></A>


<P>
stopped while it was in the foreground. The previous job may be referenced using
%_.In output pertaining to jobs (for example, the output of the
jobs command), the current job is always flagged with a
+, and the previous job with a _.</P>
<P>Simply naming a job can be used to bring it into the foreground:
%1 is a synonym for fg %1, bringing job 1 from the background into the foreground. Similarly,
%1 &amp; resumes job 1 in the background, equivalent to
bg %1.</P>
<P>The shell learns immediately whenever a job changes state. Normally,
bash waits until it is about to print a prompt
before reporting changes in a job's status so as to not interrupt any other output. If the
-b option to the set built-in command is set, bash reports such changes immediately. (See also the description of the
notify variable in &quot;Shell Variables,&quot; earlier in
this manual page.)</P>
<P>If you attempt to exit bash while jobs are stopped, the shell prints a message warning you. You may then use the
jobs command to inspect their status. If you do this, or try to exit again immediately, you are not warned again, and the
stopped jobs are terminated.</P>
<B>
<P>SIGNALS</P>
</B>
<P>When bash is interactive, it ignores SIGTERM (so that
kill 0 does not kill an interactive shell), and
SIGINT is caught and handled (so that the wait built-in is interruptible). In all cases,
bash ignores SIGQUIT. If job control is in effect,
bash ignores SIGTTIN, SIGTTOU, and SIGTSTP.</P>
<P>Synchronous jobs started by bash have signals set to the values inherited by the shell from its parent. When job control is
not in effect, background jobs (jobs started with
&amp;) ignore SIGINT and SIGQUIT. Commands run as a result of command
substitution ignore the keyboard-generated job control signals
SIGTTIN, SIGTTOU, and SIGTSTP.</P>
<B>
<P>COMMAND EXECUTION</P>
</B>
<P>After a command has been split into words, if it results in a simple command and an optional list of arguments,
the following actions are taken.</P>
<P>If the command name contains no slashes, the shell attempts to locate it. If there exists a shell function by that name,
that function is invoked as described earlier in &quot;Functions.&quot; If the name does not match a function, the shell searches for it in
the list of shell builtins. If a match is found, that builtin is invoked.</P>
<P>If the name is neither a shell function nor a builtin, and contains no slashes,
bash searches each element of the PATH for a directory containing an executable file by that name. If the search is unsuccessful, the shell prints an error message
and returns a nonzero exit status.</P>
<P>If the search is successful, or if the command name contains one or more slashes, the shell executes the named
program. Argument 0 is set to the name given, and the remaining arguments to the command are set to the arguments given, if any.</P>
<P>If this execution fails because the file is not in executable format, and the file is not a directory, it is assumed to be a
shell script, a file containing shell commands. A subshell is spawned to execute it. This subshell reinitializes itself, so that the
effect is as if a new shell had been invoked to handle the script, with the exception that the locations of commands remembered
by the parent (see hash under &quot;Shell Built-in Commands&quot;) are retained by the child.</P>
<P>If the program is a file beginning with #!, the remainder of the first line specifies an interpreter for the program. The
shell executes the specified interpreter on operating systems that do not handle this executable format themselves. The
arguments to the interpreter consist of a single optional argument following the interpreter name on the first line of the
program, followed by the name of the program, followed by the command arguments, if any.</P>
<B>
<P>ENVIRONMENT</P>
</B>
<P>When a program is invoked, it is given an array of strings called the environment. This is a list of name/value pairs, of
the form name=value.</P>

<P>The shell allows you to manipulate the environment in several ways. On invocation, the shell scans its own environment
and creates a parameter for each name found, automatically marking it for export to child processes. Executed commands
inherit the environment. The export and declare _x commands allow parameters and functions to be added to and deleted from
the environment. If the value of a parameter in the environment is modified, the new value becomes part of the
environment,</P>




<P><CENTER>
<a href="0023-0024.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0026-0027.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>