<HTML>
<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0022-0022.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0025-0025.html">Next</A></CENTER></P>



<A NAME="PAGENUM-23"><P>Page 23</P></A>


<P>
The format of here-documents is as follows:</P>

<!-- CODE SNIP //-->
<PRE>
&lt;&lt;[_]word here-document delimiter
</PRE>
<!-- END CODE SNIP //-->

<P>No parameter expansion, command substitution, pathname expansion, or arithmetic expansion is performed on
word. If any characters in word are quoted, the
delimiter is the result of quote removal on word, and the lines in the
here-document are not expanded. Otherwise, all lines of the
here-document are subjected to parameter expansion, command substitution,
and arithmetic expansion. In the latter case, the pair
\&lt;newline&gt; is ignored, and \ must be used to quote the characters
\, $, and `.</P>

<P>
If the redirection operator is &lt;&lt;_, then all leading tab characters are stripped from input lines and the line
containing delimiter. This allows here-documents within shell scripts to be indented in a natural fashion.</P>

<P>
<b>DUPLICATING FILE DESCRIPTORS</b>
</P>

<P>The redirection operator:</P>

<!-- CODE SNIP //-->
<PRE>
[n]&lt;&amp;word
</PRE>
<!-- END CODE SNIP //-->

<P>is used to duplicate input file descriptors. If
word expands to one or more digits, the file descriptor denoted by
n is made to be a copy of that file descriptor. If word evaluates to
_, file descriptor n is closed. If n is not specified, the standard input
(file descriptor 0) is used.</P>

<P>The operator:</P>

<!-- CODE SNIP //-->
<PRE>
[n]&gt;&amp;word
</PRE>
<!-- END CODE SNIP //-->

<P>is used similarly to duplicate output file descriptors. If
n is not specified, the standard output (file descriptor
1) is used. As a special case, if n is omitted, and word does not expand to one or more digits, the standard output and standard error
are redirected as described previously.</P>

<P>
<b>OPENING FILE DESCRIPTORS FOR READING AND WRITING</b>
</P>
<P>The redirection operator:</P>
<!-- CODE SNIP //-->
<PRE>
[n]&lt;&gt;word
</PRE>
<!-- END CODE SNIP //-->
<P>causes the file whose name is the expansion of word to be opened for both reading and writing on file descriptor
n, or as the standard input and standard output if
n is not specified. If the file does not exist, it is created.</P>
<B>
<P>FUNCTIONS</P>
</B>
<P>A shell function, defined as described above under &quot;Shell Grammar,&quot; stores a series of commands for later
execution. Functions are executed in the context of the current shell; no new process is created to interpret them (contrast this with
the execution of a shell script). When a function is executed, the arguments to the function become the positional
parameters during its execution. The special parameter
# is updated to reflect the change. Positional parameter
0 is unchanged.</P>
<P>Variables local to the function may be declared with the
local built-in command. Ordinarily, variables and their values
are shared between the function and its caller.</P>
<P>If the built-in command return is executed in a function, the function completes and execution resumes with the
next command after the function call. When a function completes, the values of the positional parameters and the
special parameter # are restored to the values they had prior to function execution.</P>
<P>Function names may be listed with the _f option to the
declare or typeset built-in commands. Functions may be
exported so that subshells automatically have them defined with the
_f option to the export builtin.</P>
<P>Functions may be recursive. No limit is imposed on the number of recursive calls.</P>
<B>
<P>ALIASES</P>
</B>
<P>The shell maintains a list of aliases that may be set and unset with the
alias and unalias built-in commands. (See
&quot;Shell Built-in Commands.&quot;). The first word of each command, if unquoted, is checked to see if it has an alias. If so, that word
is replaced by the text of the alias. The alias name and the replacement text may contain any valid shell input, including
the meta characters listed above, with the exception that the alias name may not contain
=. The first word of the replacement text</P>

<A NAME="PAGENUM-24"><P>Page 24</P></A>


<P>
is tested for aliases, but a word that is identical to an alias being expanded is not expanded a second time. This means
that one may alias ls to ls _F, for instance, and
bash does not try to recursively expand the replacement text. If the last
character of the alias value is a blank, then the next command word following the alias is also checked for alias expansion.</P>
<P>Aliases are created and listed with the alias command, and removed with the
unalias command.</P>
<P>There is no mechanism for using arguments in the replacement text, as in
csh. If arguments are needed, a shell function should be used.</P>
<P>Aliases are not expanded when the shell is not interactive.</P>
<P>The rules concerning the definition and use of aliases are somewhat confusing.
bash always reads at least one complete line of input before executing any of the commands on that line. Aliases are expanded when a command is read, not when it
is executed. Therefore, an alias definition appearing on the same line as another command does not take effect until the
next line of input is read. This means that the commands following the alias definition on that line are not affected by the
new alias. This behavior is also an issue when functions are executed. Aliases are expanded when the function definition is
read, not when the function is executed, because a function definition is itself a compound command. As a consequence,
aliases defined in a function are not available until after that function is executed. To be safe, always put alias definitions on
a separate line, and do not use alias in compound commands.</P>
<P>Note that for almost every purpose, aliases are superseded by shell functions.
</P>

<B>
<P>JOB CONTROL</P>
</B>

<P>Job control refers to the ability to selectively stop (suspend) the execution of processes and continue (resume) their
execution at a later point. A user typically employs this facility via an interactive interface supplied jointly by the system's
terminal driver and bash.</P>

<P>The shell associates a job with each pipeline. It keeps a table of currently executing jobs, which may be listed with the
jobs command. When bash starts a job asynchronously (in the background), it prints a line that looks like this:
</P>

<!-- CODE SNIP //-->
<PRE>
[1] 25647
</PRE>
<!-- END CODE SNIP //-->

<P>indicating that this job is job number 1 and that the process ID of the last process in the pipeline associated with this job
is 25647. All of the processes in a single pipeline are members of the same job.
bash uses the job abstraction as the basis for job control.</P>
<P>To facilitate the implementation of the user interface to job control, the system maintains the notion of a current
terminal process group ID. Members of this process group (processes whose process group ID is equal to the current terminal
process group ID) receive keyboard-generated signals such as
SIGINT. These processes are said to be in the foreground.
Background processes are those whose process group ID differs from the terminal's; such processes are immune to
keyboard-generated signals. Only foreground processes are allowed to read from or write to the terminal. Background processes that attempt
to read from (write to) the terminal are sent a
SIGTTIN (SIGTTOU) signal by the terminal driver, which, unless caught,
suspends the process.</P>
<P>If the operating system on which bash is running supports job control,
bash allows you to use it. Typing the suspend character (typically
^Z, Control-Z) while a process is running causes that process to be stopped and returns you to
bash. Typing the delayed suspend character (typically
^Y, Control-Y) causes the process to be stopped when it attempts to
read input from the terminal, and control to be returned to
bash. You may then manipulate the state of this job, using the
bg command to continue it in the background, the fg
command to continue it in the foreground, or the
kill command to kill it. A Ctrl+Z takes effect immediately, and has the additional side effect of causing pending output and typeahead to
be discarded.</P>
<P>There are a number of ways to refer to a job in the shell. The character
% introduces a job name. Job number n may be referred to as
%n. A job may also be referred to using a prefix of the name used to start it, or using a substring that appears
in its command line. For example, %ce refers to a stopped
ce job. If a prefix matches more than one job,
bash reports an error. Using %?ce, on the other hand, refers to any job containing the string
ce in its command line. If the substring matches
more than one job, bash reports an error. The symbols
%% and %+ refer to the shell's notion of the current job, which is the last
job</P>



<P><CENTER>
<a href="0022-0022.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0025-0025.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>