<HTML>
<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0030-0030.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0034-0034.html">Next</A></CENTER></P>



<A NAME="PAGENUM-31"><P>Page 31</P></A>


<TABLE>

<TR><TD>
transpose_chars (C_t)
</TD><TD>
Drag the character before point forward over the character at point. Point
moves forward as well. If point is at the end of the line, then transpose the
two characters before point. Negative arguments don't work.
</TD></TR><TR><TD>
transpose_words (M_t)
</TD><TD>
Drag the word behind the cursor past the word in front of the cursor,
moving the cursor over that word as well.
</TD></TR><TR><TD>
upcase_word (M_u)
</TD><TD>
Uppercase the current (or following) word. With a negative argument, do
the previous word, but do not move point.
</TD></TR><TR><TD>
downcase_word (M_l)
</TD><TD>
Lowercase the current (or following) word. With a negative argument, do
the previous word, but do not move point.
</TD></TR><TR><TD>
capitalize_word (M_c)
</TD><TD>
Capitalize the current (or following) word. With a negative argument, do
the previous word, but do not move point.
</TD></TR></TABLE>

<P>
Killing and Yanking
</P>

<TABLE>

<TR><TD>
kill_line (C_k)
</TD><TD>
Kill the text from the current cursor position to the end of the line.
</TD></TR><TR><TD>
backward_kill_line (C_x C_Rubout)
</TD><TD>
Kill backward to the beginning of the line.
</TD></TR><TR><TD>
UNIX_line_discard (C_u)
</TD><TD>
Kill backward from point to the beginning of the line.
</TD></TR><TR><TD>
kill_whole_line
</TD><TD>
Kill all characters on the current line, no matter where the cursor is. By
default, this is unbound.
</TD></TR><TR><TD>
kill_word (M_d)
</TD><TD>
Kill from the cursor to the end of the current word, or if between words, to
the end of the next word. Word boundaries are the same as those used by
forward_word.
</TD></TR><TR><TD>
backward_kill_word (M_Rubout)
</TD><TD>
Kill the word behind the cursor. Word boundaries are the same as those used
by backward_word.
</TD></TR><TR><TD>
UNIX_word_rubout (C_w)
</TD><TD>
Kill the word behind the cursor, using whitespace as a word boundary. The
word boundaries are different from
backward_kill_word.
</TD></TR><TR><TD>
delete_horizontal_space
</TD><TD>
Delete all spaces and tabs around point. By default, this is unbound.
</TD></TR><TR><TD>
yank (C_y)
</TD><TD>
Yank the top of the kill ring into the buffer at the cursor.
</TD></TR><TR><TD>
yank_pop (M_y)
</TD><TD>
Rotate the kill_ring, and yank the new top. Only works following
yank or yank_pop.
</TD></TR></TABLE>

<P>Numeric Arguments</P>

<TABLE>

<TR><TD>
digit_argument (M_0, M_1, ..., M&#151;)
</TD><TD>
Add this digit to the argument already accumulating, or start a new
argument. M&#151; starts a negative argument.
</TD></TR><TR><TD>
universal_argument
</TD><TD>
Each time this is executed, the argument count is multiplied by four.
The argument count is initially one, so executing this function the first time
makes the argument count four. By default, this is not bound to a key.
</TD></TR></TABLE>

<P>Completing</P>

<TABLE>

<TR><TD>
complete (TAB)
</TD><TD>
Attempt to perform completion on the text before point.
Bash attempts completion treating the text as a variable (if the text begins with
$), username (if the text begins with ~), hostname (if the text begins with
@), or command (including aliases and functions) in turn. If none of these produces a
match, filename completion is attempted.
</TD></TR><TR><TD>
possible_completions (M-?)
</TD><TD>
List the possible completions of the text before point.
</TD></TR><TR><TD>
insert_completions
</TD><TD>
Insert all completions of the text before point that would have been generated
by possible_completions. By default, this is not bound to a key.
</TD></TR><TR><TD>
complete_filename (M_/)
</TD><TD>
Attempt filename completion on the text before point.
</TD></TR></TABLE>

<!-- CODE SNIP //-->
<PRE>								continues
</PRE>
<!-- END CODE SNIP //-->


<A NAME="PAGENUM-32"><P>Page 32</P></A>


<P>Completing</P>

<TABLE>

<TR><TD>
possible_filename_completions (C_x /)
</TD><TD>
List the possible completions of the text before point, treating it as a filename.
</TD></TR><TR><TD>
complete_username (M_~)
</TD><TD>
Attempt completion on the text before point, treating it as a username.
</TD></TR><TR><TD>
possible_username_completions (C_x ~)
</TD><TD>
List the possible completions of the text before point, treating it as a username.
</TD></TR><TR><TD>
complete_variable (M_$)
</TD><TD>
Attempt completion on the text before point, treating it as a shell variable.
</TD></TR><TR><TD>
possible_variable_completions (C_x $)
</TD><TD>
List the possible completions of the text before point, treating it as a
shell variable.
</TD></TR><TR><TD>
complete_hostname (M_@)
</TD><TD>
Attempt completion on the text before point, treating it as a hostname.
</TD></TR><TR><TD>
possible_hostname_completions (C_x @)
</TD><TD>
List the possible completions of the text before point, treating it as a hostname.
</TD></TR><TR><TD>
complete_command (M_!)
</TD><TD>
Attempt completion on the text before point, treating it as a command
name. Command completion attempts to match the text against aliases, reserved
words, shell functions, builtins, and finally executable filenames, in that order.
</TD></TR><TR><TD>
possible_command_completions (C_x !)
</TD><TD>
List the possible completions of the text before point, treating it as a
command name.
</TD></TR><TR><TD>
dynamic_complete_history (M-TAB)
</TD><TD>
Att empt completion on the text before point, comparing the text against
lines from the history list for possible completion matches.
</TD></TR><TR><TD>
complete_into_braces (M_{)
</TD><TD>
Perform filename completion and return the list of possible completions
enclosed within braces so the list is available to the shell. (See &quot;Brace Expansion,&quot; earlier
in this manual page.)
</TD></TR></TABLE>

<P>
Keyboard Macros</P>

<TABLE>

<TR><TD>
start_kbd_macro (C-x ()
</TD><TD>
Begin saving the characters typed into the current keyboard macro.
</TD></TR><TR><TD>
end_kbd_macro (C-x ))
</TD><TD>
Stop saving the characters typed into the current keyboard macro and save
the definition.
</TD></TR><TR><TD>
call_last_kbd_macro (C-x e)
</TD><TD>
Re-execute the last keyboard macro defined, by making the characters in
the macro appear as if typed at the keyboard.
</TD></TR></TABLE>

<P>Miscellaneous</P>

<TABLE>

<TR><TD>
re_read_init_file (C_x C_r)
</TD><TD>
Read in the contents of your init file, and incorporate any bindings or
variable assignments found there.
</TD></TR><TR><TD>
abort (C_g)
</TD><TD>
Abort the current editing command and ring the terminal's bell (subject to
the setting of bell_style).
</TD></TR><TR><TD>
do_uppercase_version (M_a, M_b, ...)
</TD><TD>
Run the command that is bound to the corresponding uppercase character.
</TD></TR><TR><TD>
prefix_meta (ESC)
</TD><TD>
Metafy the next character typed. ESC-f is equivalent to Meta_f.
</TD></TR><TR><TD>
undo (C-_, C_x C_u)
</TD><TD>
Incremental undo, separately remembered for each line.
</TD></TR><TR><TD>
revert_line (M_r)
</TD><TD>
Undo all changes made to this line. This is like typing the undo
command enough times to return the line to its initial state.
</TD></TR><TR><TD>
tilde_expand (M_~)
</TD><TD>
Perform tilde expansion on the current word.
</TD></TR><TR><TD>
dump_functions
</TD><TD>
Print all of the functions and their key bindings to the
readline output stream. If a numeric argument is supplied, the output is formatted in such a way that it
can be made part of an inputrc file.
</TD></TR><TR><TD>
display_shell_version (C_x C_v)
</TD><TD>
Display version information about the current instance of
bash.
</TD></TR><TR><TD>
emacs_editing_mode (C_e)
</TD><TD>
When in vi editing mode, this causes a switch to
emacs editing mode.
</TD></TR></TABLE>

<B>
<P>HISTORY</P>
</B>
<P>When interactive, the shell provides access to the command history, the list of commands previously typed. The text of
the last HISTSIZE commands (default 500) is saved in a history list. The shell stores each command in the history list prior
to
</P>

<A NAME="PAGENUM-33"><P>Page 33</P></A>


<P>
parameter and variable expansion (see &quot;Expansion,&quot; earlier in this manual page) but after history expansion is
performed, subject to the values of the shell variables
command_oriented_history and HISTCONTROL. On startup, the history is
initialized from the file named by the variable
HISTFILE (default ~/.bash_history). HISTFILE is truncated, if necessary, to contain
no more than HISTFILESIZE lines. The built-in command
fc (see Shell Built-in Commands, later in this manual page) may
be used to list or edit and re-execute a portion of the history list. The
history builtin can be used to display the history list
and manipulate the history file. When using the command-line editing, search commands are available in each editing mode
that provide access to the history list. When an interactive shell exits, the last
HISTSIZE lines are copied from the history list to
HISTFILE. If HISTFILE is unset, or if the history file is unwritable, the history is not saved.
</P>

<B>
<P>HISTORY EXPANSION</P>
</B>

<P>The shell supports a history expansion feature that is similar to the history expansion in
csh. This section describes what syntax features are available. This feature is enabled by default for interactive shells, and can be disabled using the
H option to the set built-in command. (See &quot;Shell Built-in Commands,&quot; later in this manual page.) Noninteractive shells do not
perform history expansion.</P>

<P>History expansion is performed immediately after a complete line is read, before the shell breaks it into words. It takes
place in two parts. The first is to determine which line from the previous history to use during substitution. The second is to
select portions of that line for inclusion into the current one. The line selected from the previous history is the event, and
the portions of that line that are acted upon are words. The line is broken into words in the same fashion as when reading
input, so that several meta character_separated words surrounded by quotes are considered as one word. Only the backslash
(\) and single quotes can quote the history escape character, which is
! by default.</P>

<P>The shell allows control of the various characters used by the history expansion mechanism. (See the description of
histchars under &quot;Shell Variables,&quot; earlier in this manual page.)</P>

<P>
<B>EVENT DESIGNATORS</B>
</P>

<P>An event designator is a reference to a command line entry in the history list.</P>

<TABLE>

<TR><TD>
!
</TD><TD>
Start a history substitution, except when followed by a blank, newline,
=, or (.
</TD></TR><TR><TD>
!!
</TD><TD>
Refer to the previous command. This is a synonym for
!_1.
</TD></TR><TR><TD>
!n
</TD><TD>
Refer to command line n.
</TD></TR><TR><TD>
!_n
</TD><TD>
Refer to the current command line minus
n.
</TD></TR><TR><TD>
!string
</TD><TD>
Refer to the most recent command starting with
string.
</TD></TR><TR><TD>
!?string[?]
</TD><TD>
Refer to the most recent command containing
string.
</TD></TR><TR><TD>
^string1^string2^
</TD><TD>
Quick substitution. Repeat the last command, replacing
string1 with string2. Equivalent to
!!:s/string1/string2/. (See &quot;Modifiers,&quot; later in this manual page.)
</TD></TR><TR><TD>
!#
</TD><TD>
The entire command line typed so far.
</TD></TR></TABLE>

<P>
<B>WORD DESIGNATORS</B>
</P>

<P>A colon (:) separates the event specification from the word designator. It can be omitted if the word designator begins with
a ^, $, *, or %. Words are numbered from the beginning of the line, with the first word being denoted by a
0 (zero).</P>

<TABLE>

<TR><TD>
0 (zero)
</TD><TD>
The zeroth word. For the shell, this is the command word.
</TD></TR><TR><TD>
n
</TD><TD>
The nth word.
</TD></TR><TR><TD>
^
</TD><TD>
The first argument. That is, word 1.
</TD></TR><TR><TD>
$
</TD><TD>
The last argument.
</TD></TR><TR><TD>
%
</TD><TD>
The word matched by the most recent
?string? search.
</TD></TR><TR><TD>
x_y
</TD><TD>
A range of words; _y abbreviates 0_y.
</TD></TR><TR><TD>
*
</TD><TD>
All of the words but the zeroth. This is a synonym for
1_$. It is not an error to use * if there is just one word in the event; the empty string is returned in that case.
</TD></TR><TR><TD>
x*
</TD><TD>
Abbreviates x_$.
</TD></TR><TR><TD>
x_
</TD><TD>
Abbreviates x_$ like x*, but omits the last word.
</TD></TR></TABLE>




<P><CENTER>
<a href="0030-0030.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0034-0034.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>