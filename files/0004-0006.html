<HTML>
<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0001-0003.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0007-0008.html">Next</A></CENTER></P>



<A NAME="PAGENUM-4"><P>Page 4</P></A>


<TABLE>

<TR><TD>
/usr/lib/groff/font/devps/text.enc
</TD><TD>
Encoding used for text fonts
</TD></TR><TR><TD>
/usr/lib/groff/font/devps/generate/textmap
</TD><TD>
Standard mapping
</TD></TR></TABLE>

<B>
SEE ALSO
</B>

<P>
groff(1), grops(1), groff_font(5), perl(1)
Groff Version 1.09, 14 February 1994
</P>

<H3><A NAME="ch01_ 5">
ansi2knr
</A></H3>

<P>ansi2knr&#151;Convert ANSI C to Kernighan &amp; Ritchie C
</P>

<B>
<P>SYNOPSIS</P>
</B>

<!-- CODE SNIP //-->
<PRE>
ansi2knr input_file output_file
</PRE>
<!-- END CODE SNIP //-->

<B>
<P>DESCRIPTION</P>
</B>

<P>If no output_file is supplied, output goes to
stdout. There are no error messages.
</P>

<P>ansi2knr recognizes functions by seeing a nonkeyword identifier at the left margin, followed by a left parenthesis, with a
right parenthesis as the last character on the line. It will recognize a multiline header if the last character on each line but the last
is a left parenthesis or comma. These algorithms ignore whitespace and comments, except that the function name must be
the first thing on the line.
</P>

<P>The following constructs will confuse it:
</P>

<UL>
<LI>     Any other construct that starts at the left margin and follows the above syntax (such as a macro or function call)
<LI>     Macros that tinker with the syntax of the function header
</UL>

<P>
31 December 1990
</P>

<H3><A NAME="ch01_ 6">
anytopnm
</A></H3>

<P>anytopnm&#151;Attempt to convert an unknown type of image file to a portable anymap
</P>

<B>
<P>SYNOPSIS</P>
</B>

<!-- CODE SNIP //-->
<PRE>
anytopnm file
</PRE>
<!-- END CODE SNIP //-->

<B>
<P>DESCRIPTION</P>
</B>

<P>anytopnm uses the file program, possibly augmented by the magic numbers file included with
PBMPLUS, to try to figure out what type of image file it is. If that fails (very few image formats have magic numbers), looks at the filename extension.
If that fails, punt.
</P>

<P>The type of the output file depends on the input file.
</P>

<B>
<P>SEE ALSO</P>
</B>

<!-- CODE SNIP //-->
<PRE>
pnmfile(1), pnm(5), file(1)
</PRE>
<!-- END CODE SNIP //-->

<B>
<P>BUGS</P>
</B>

<P>It's a script. Scripts are not portable to non-UNIX environments.
</P>

<B>
<P>AUTHOR</P>
</B>
<P>Copyright &quot; 1991 by Jef Poskanzer
</P>
<P>
27 July 1990
</P>

<A NAME="PAGENUM-5"><P>Page 5</P></A>


<H3><A NAME="ch01_ 7">
appres
</A></H3>

<P>appres&#151;List X application resource database
</P>

<B>
<P>SYNOPSIS</P>
</B>

<!-- CODE SNIP //-->
<PRE>
appres [[class [instance]] [_1] [toolkitoptions]
</PRE>
<!-- END CODE SNIP //-->

<B>
<P>DESCRIPTION</P>
</B>

<P>The appres program prints the resources seen by an application (or subhierarchy of an application) with the specified
class and instance names. It can be used to determine which resources a particular program will load. For example,
</P>

<!-- CODE SNIP //-->
<PRE>
% appres XTerm
</PRE>
<!-- END CODE SNIP //-->

<P>will list the resources that any xterm program will load. If no application class is specified, the class
-AppResTest- is used.
</P>

<P>To match a particular instance name, specify an instance name explicitly after the class name, or use the normal
Xt toolkit option. For example,
</P>

<!-- CODE SNIP //-->
<PRE>
% appres XTerm myxterm
</PRE>
<!-- END CODE SNIP //-->

<P>or
</P>

<!-- CODE SNIP //-->
<PRE>
% appres XTerm _name myxterm
</PRE>
<!-- END CODE SNIP //-->

<P>To list resources that match a subhierarchy of an application, specify hierarchical class and instance names. The number
of class and instance components must be equal, and the instance name should not be specified with a toolkit option.
For example,
</P>

<!-- CODE SNIP //-->
<PRE>
% appres Xman.TopLevelShell.Form xman.topBox.form
</PRE>
<!-- END CODE SNIP //-->

<P>will list the resources of widgets of xman
topBox hierarchy. To list just the resources matching a specific level in the
hierarchy, use the _1 option. For example,
</P>

<!-- CODE SNIP //-->
<PRE>
% appres XTerm.VT100 xterm.vt100 _1
</PRE>
<!-- END CODE SNIP //-->

<P>will list the resources matching the xterm
vt100 widget.
</P>

<B>
<P>SEE ALSO</P>
</B>

<!-- CODE SNIP //-->
<PRE>
X(1), xrdb(1), listres(1)
</PRE>
<!-- END CODE SNIP //-->

<B>
<P>AUTHOR</P>
</B>

<P>Jim Fulton (MIT X Consortium)
</P>

<P>
X Version 11 Release 6
</P>

<H3><A NAME="ch01_ 8">
ar
</A></H3>

<P>ar&#151;Create, modify, and extract from archives
</P>

<B>
<P>SYNOPSIS</P>
</B>

<!-- CODE SNIP //-->
<PRE>
ar [ - ] dmpqrtx[abcilosuvV] [ membername ] archive files ...
</PRE>
<!-- END CODE SNIP //-->

<B>
<P>DESCRIPTION</P>
</B>

<P>The GNU ar program creates, modifies, and extracts from archives. An archive is a single file holding a collection of
other files in a structure that makes it possible to retrieve the original individual files (called members of the archive).
</P>

<P>The original files' contents, mode (permissions), timestamp, owner, and group are preserved in the archive, and may
be reconstituted on extraction.
</P>

<A NAME="PAGENUM-6"><P>Page 6</P></A>


<P>GNU ar can maintain archives whose members have names of any length; however, depending on how ar is configured
on your system, a limit on member-name length may be imposed (for compatibility with archive formats maintained with
other tools). If it exists, the limit is often 15 characters (typical of formats related to
a.out) or 16 characters (typical of formats related to
coff).
</P>

<P>ar is considered a binary utility because archives of this sort are most often used as libraries holding commonly
needed subroutines.
</P>

<P>ar will create an index to the symbols defined in relocatable object modules in the archive when you specify the modifier
s. Once created, this index is updated in the archive whenever ar makes a change to its contents (save for the
q update operation). An archive with such an index speeds up linking to the library, and allows routines in the library to call
each other without regard to their placement in the archive.
</P>

<P>You may use nm _s or nm &#151;print_armap to list this index table. If an archive lacks the table, another form of
ar called ranlib can be used to add just the table.
</P>

<P>ar insists on at least two arguments to execute: one keyletter specifying the operation (optionally accompanied by
other keyletters specifying modifiers ), and the archive name to act on.
</P>

<P>Most operations can also accept further files arguments, specifying particular files to operate on.
</P>

<B>
<P>OPTIONS</P>
</B>

<P>GNU ar allows you to mix the operation code p and modifier flags
mod in any order, within the first command-line argument.
</P>

<P>If you wish, you may begin the first command-line argument with a dash.
</P>

<P>The p keyletter specifies what operation to execute; it may be any of the following, but you must specify only one of them:
</P>

<TABLE>

<TR><TD>
d
</TD><TD>
Delete modules from the archive. Specify the names of modules to be deleted as files ; the archive
is untouched if you specify no files to delete.
</TD></TR><TR><TD>
</TD><TD>
If you specify the v modifier, ar will list each module as it is deleted.
</TD></TR><TR><TD>
m
</TD><TD>
Use this operation to move members in an archive.
</TD></TR><TR><TD>
</TD><TD>
The ordering of members in an archive can make a difference in how programs are linked using
the library if a symbol is defined in more than one member.
</TD></TR><TR><TD>
</TD><TD>
If no modifiers are used with m, any members you name in the files arguments are moved to the end
of the archive; you can use the a, b, or i modifiers to move them to a specified place instead.
</TD></TR><TR><TD>
p
</TD><TD>
Print the specified members of the archive to the standard output file. If the
v modifier is specified, show the membername before copying its contents to standard output.<BR>
</TD></TR><TR><TD>
</TD><TD>
If you specify no files, all the files in the archive are printed.
</TD></TR><TR><TD>
q
</TD><TD>
Quick append; add files to the end of archive without checking for replacement.
</TD></TR><TR><TD>
</TD><TD>
The modifiers a, b, and i do not affect this operation; new members are always placed at the end of
the archive.
</TD></TR><TR><TD>
</TD><TD>
The modifier v makes ar list each file as it is appended.
</TD></TR><TR><TD>
</TD><TD>
Since the point of this operation is speed, the archive's symbol table index is not updated, even if
it already existed; you can use ar s or ranlib explicitly to update the symbol table index.
</TD></TR><TR><TD>
r
</TD><TD>
Insert files into archive (with replacement). This operation differs from
q in that any previously existing members are deleted if their names match those being added.
</TD></TR><TR><TD>
</TD><TD>
If one of the files named in files doesn't exist,
ar displays an error message and leaves undisturbed
any existing members of the archive matching that name.
</TD></TR><TR><TD>
</TD><TD>
By default, new members are added at the end of the file, but you may use one of the modifiers
a, b, or i to request placement relative to some existing member.
</TD></TR><TR><TD>
</TD><TD>
The modifier v used with this operation elicits a line of output for each file inserted, along with one
of the letters a or r to indicate whether the file was appended (no old member deleted) or replaced.
</TD></TR></TABLE>



<P><CENTER>
<a href="0001-0003.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0007-0008.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>