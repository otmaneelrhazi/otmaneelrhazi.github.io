<HTML>

<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0389-0390.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0394-0396.html">Next</A></CENTER></P>



<A NAME="PAGENUM-391"><P>Page 391</P></A>


<P><B>
Edge Enhancement. (-0.1 &gt; = alpha &gt; = -0.9)
</B></P>

<P>This is the opposite type of filter to the smoothing filter. It enhances edges. The
alpha parameter controls the amount of edge enhancement, from subtle
(-0.1) to blatant (-0.9). The radius parameter controls the effective radius as usual,
but useful values are between 0.5 and 0.9. Try starting with values of
alpha = 0.3, radius = 0.8.
</P>

<P><B>
COMBINATION USE
</B></P>

<P>The various modes of pnmnlfilt can be used one after the other to get the desired result. For instance to turn a
monochrome dithered image into a grayscale image, you could try one or two passes of the smoothing filter, followed by a pass of
the optimal estimation filter, then some subtle edge enhancement. Note that using edge enhancement is only likely to be
useful after one of the nonlinear filters (alpha-trimmed mean or optimal estimation filter), as edge enhancement is the
direct opposite of smoothing.
</P>

<P>For reducing color quantization noise in images (that is, turning GIF files back into 24-bit files), you could try a pass of
the optimal estimation filter (alpha 1.2, radius
1.0), a pass of the median filter (alpha 0.5, radius
0.55), and possibly a pass of the edge enhancement filter. Several passes of the optimal estimation filter with declining
alpha values are more effective than a single pass with a large
alpha value. As usual, there is a tradeoff between filtering effectiveness and loosing detail.
Experimentation is encouraged.
</P>

<P><B>
REFERENCES
</B>
</P>
<P>The alpha-trimmed mean filter is based on the description in
IEEE CG&amp;A, May 1990, page 23, by Mark E. Lee and
Richard A. Redner, and has been enhanced to allow continuous alpha adjustment.
</P>

<P>The optimal estimation filter is taken from an article &quot;Converting Dithered Images Back to Grayscale&quot; by Allen Stenger,
Dr. Dobb's Journal, November 1992, and this article references &quot;Digital Image Enhancement and Noise Filtering by Use of
Local Statistics&quot; by Jong-Sen Lee, IEEE Transactions on Pattern Analysis and Machine
Intelligence, March 1980.
</P>

<P>The edge enhancement details are from
pgmenhance(1), which is taken from Philip R. Thompson's
xim program, which in turn took it from Section 6 of &quot;Digital Halftones by Dot Diffusion&quot; by D. E. Knuth,
ACM Transaction on Graphics Vol. 6, No. 4, October 1987, which in turn got it from two 1976 papers by J. F. Jarvis et al.
</P>

<P><B>
SEE ALSO
</B>
</P>
<!-- CODE SNIP //-->
<PRE>pgmenhance(1), pnmconvol(1), pnm(5)
</PRE>
<!-- END CODE SNIP //-->

<P><B>
BUGS
</B>
</P>
<P>Integers and tables may overflow if
PPM_MAXMAXVAL is greater than 255.
</P>

<P><B>
AUTHOR
</B>
</P>
<P>Graeme W. Gill (graeme@labtam.oz.au).
</P>

<P>5 February 1993
</P>

<H3><A NAME="ch01_ 276">
pnmnoraw
</A></H3>
<P>pnmnoraw&#151;Force a portable anymap into plain format
</P>

<P><B>
SYNOPSIS
</B>
</P>
<!-- CODE SNIP //-->
<PRE>
pnmnoraw [pnmfile]
</PRE>
<!-- END CODE SNIP //-->


<P><B>
DESCRIPTION
</B>
</P>
<P>pnmnoraw reads a portable anymap as input and writes it out in plain (nonraw) format. This is fairly useless if you
haven't defined the PBMPLUS_RAWBITS compile-time option.
</P>

<A NAME="PAGENUM-392"><P>Page 392</P></A>


<P><B>
SEE ALSO
</B>
</P>
<!-- CODE SNIP //-->
<PRE>pnm(5)
</PRE>
<!-- END CODE SNIP //-->

<P><B>
AUTHOR
</B>
</P>
<P>Copyright &quot; 1991 by Jef Poskanzer.
</P>

<P>8 January 1991
</P>

<H3><A NAME="ch01_ 277">
pnmpad
</A></H3>
<P>pnmpad&#151;Add borders to portable anymap
</P>

<P><B>
SYNOPSIS
</B>
</P>
<!-- CODE SNIP //-->
<PRE>
pnmpad [-white|-black] [-l#] [-r#] [-t#] [-b#] [pnmfile]
</PRE>
<!-- END CODE SNIP //-->

<P><B>
DESCRIPTION
</B>
</P>
<P>pnmpad reads a portable anymap as input and outputs a portable anymap with extra borders of the sizes specified. The color
of the borders can be set to black or white (default
black).
</P>

<P><B>
SEE ALSO
</B>
</P>
<!-- CODE SNIP //-->
<PRE>pbmmake(1), pnmpaste(1), pbm(5)
</PRE>
<!-- END CODE SNIP //-->

<P><B>
AUTHOR
</B>
</P>
<P>Copyright &quot; 1990 by Angus Duggan. Copyright
&quot; 1989 by Jef Poskanzer.
</P>

<H3><A NAME="ch01_ 278">
pnmpaste
</A></H3>
<P>pnmpaste&#151;Paste a rectangle into a portable anymap
</P>

<P><B>
SYNOPSIS
</B>
</P>
<!-- CODE SNIP //-->
<PRE>
pnmpaste [-replace|-or|-and |-xor] frompnmfile x y [intopnmfile]
</PRE>
<!-- END CODE SNIP //-->

<P><B>
DESCRIPTION
</B>
</P>
<P>pnmpaste reads two portable anymaps as input, inserts the first anymap into the second at the specified location, and
produces a portable anymap the same size as the second as output. If the second anymap is not specified, it is read from
stdin. The x and y can be negative, in which case they are interpreted relative to the right and bottom of the anymap, respectively.
</P>
<P>This tool is most useful in combination with
pnmcut. For instance, if you want to edit a small segment of a large image,
and your image editor cannot edit the large image, you can cut out the segment you are interested in, edit it, and then paste
it back in.
</P>
<P>Another useful companion tool is pbmmask.
</P>
<P>The optional flag specifies the operation to use when doing the paste. The default is
-replace. The other logical operations are only allowed if both input images are bitmaps. These operations act as if white is
TRUE and black is FALSE.
</P>
<P>All flags can be abbreviated to their shortest unique prefix.
</P>

<P><B>
SEE ALSO
</B>
</P>
<!-- CODE SNIP //-->
<PRE>
pnmcut(1), pnminvert(1), pnmarith(1), pnm(5),
pbmmask(1)
</PRE>
<!-- END CODE SNIP //-->

<A NAME="PAGENUM-393"><P>Page 393</P></A>


<P><B>
AUTHOR
</B></P>
<P>Copyright &quot; 1989, 1991 by Jef Poskanzer.
</P>

<P>21 February 1991
</P>

<H3><A NAME="ch01_ 279">
pnmrotate
</A></H3>
<P>pnmrotate&#151;Rotate a portable anymap by some angle
</P>

<P><B>
SYNOPSIS
</B>
</P>
<!-- CODE SNIP //-->
<PRE>
pnmrotate [-noantialias] angle [pnmfile]
</PRE>
<!-- END CODE SNIP //-->

<P><B>
DESCRIPTION
</B>
</P>
<P>pnmrotate reads a portable anymap as input, rotates it by the specified angle, and produces a portable anymap as output.
If the input file is in color, the output will be, too; otherwise, it will be grayscale. The angle is in degrees
(floating-point), measured counter-clockwise. It can be negative, but it should be between -90 and 90. Also, for rotations greater than
45 degrees you may get better results if you first use
pnmflip to do a 90-degree rotation and then
pnmrotate less than 45 degrees back the other direction.
</P>

<P>The rotation algorithm is Alan Paeth's three-shear method. Each shear is implemented by looping over the source pixels
and distributing fractions to each of the destination pixels. This has an antialiasing effect&#151;it avoids jagged edges and
similar artifacts. However, it also means that the original colors or gray levels in the image are modified. If you need to
keep precisely the same set of colors, you can use the
-noantialias flag. This does the shearing by moving pixels without
changing their values. If you want antialiasing and don't care about the precise colors, but still need a limited
*number* of colors, you can run the result through
ppmquant.
</P>

<P>All flags can be abbreviated to their shortest unique prefix.
</P>

<P><B>
REFERENCES
</B>
</P>
<P>&quot;A Fast Algorithm for General Raster Rotation&quot; by Alan Paeth,
Graphics Interface '86, pages 77_81.
</P>

<P><B>
SEE ALSO
</B>
</P>
<!-- CODE SNIP //-->
<PRE>
pnmshear(1), pnmflip(1), pnm(5), ppmquant(1)
</PRE>
<!-- END CODE SNIP //-->

<P><B>
AUTHOR
</B>
</P>
<P>Copyright &quot; 1989, 1991 by Jef Poskanzer.
</P>

<P>12 January 1991
</P>

<H3><A NAME="ch01_ 280">
pnmscale
</A></H3>
<P>pnmscale&#151;Scale a portable anymap
</P>

<P><B>
SYNOPSIS
</B>
</P>
<!-- CODE //-->
<PRE>
pnmscale s [pnmfile]
pnmscale -xsize|-width|-ysize| -height s [pnmfile]
pnmscale -xscale|-yscale s [pnmfile]
pnmscale -xscale|-xsize|-width s -yscale|-ysize|-height s [pnmfile]
pnmscale -xysize x y [pnmfile]
pnmscale _pixels n [pnmfile]
</PRE>
<!-- END CODE //-->



<P><CENTER>
<a href="0389-0390.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0394-0396.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>