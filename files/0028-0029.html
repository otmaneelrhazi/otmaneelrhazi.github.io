<HTML>
<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0026-0027.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0030-0030.html">Next</A></CENTER></P>



<A NAME="PAGENUM-28"><P>Page 28</P></A>


<P>When entering the text of a macro, single or double quotes should be used to
indicate a macro definition. Unquoted text is assumed to be a function name. Backslash will quote any character in the macro text, including
&quot; and `.</P>
<P>bash allows the current readline key bindings to be displayed or modified with the
bind built-in command. The editing mode may be switched during interactive use by using the
_o option to the set built-in command. (See &quot;Shell
Built-in Commands.&quot;)</P>
<P>Readline has variables that can be used to further customize its behavior. A variable may be set in the
inputrc file with a statement of the form:</P>
<!-- CODE SNIP //-->
<PRE>
set variable_name value
</PRE>
<!-- END CODE SNIP //-->
<P>Except where noted, readline variables can take the values
On or Off. The variables and their default values are as follows:</P>

<TABLE>

<TR><TD>
horizontal_scroll_mode (Off)
</TD><TD>
When set to On, makes
readline use a single line for display, scrolling the
input horizontally on a single screen line when it becomes longer than the screen
width rather than wrapping to a new line.</P>
</TD></TR><TR><TD>
editing_mode (emacs)
</TD><TD>
Controls whether
readline begins with a set of key bindings similar to
emacs or vi. editing_mode can be set to either
emacs or vi.
</TD></TR><TR><TD>
mark_modified_lines (Off)
</TD><TD>
If set to On, history lines that have been modified are displayed with a
preceding asterisk (*).
</TD></TR><TR><TD>
bell_style (audible)
</TD><TD>
Controls what happens when
readline wants to ring the terminal bell. If set to
none, readline never rings the bell. If set to
visible, readline uses a visible bell if one is available. If set to
audible, readline attempts to ring the terminal's bell.
</TD></TR><TR><TD>
comment_begin (&quot;#&quot;)
</TD><TD>
The string that is inserted in
vi mode when the vi_comment command is executed.
</TD></TR><TR><TD>
meta_flag (Off)
</TD><TD>
If set to On, readline will enable eight-bit input (that is, it will not strip the high
bit from the characters it reads), regardless of what the terminal claims it can support.
</TD></TR><TR><TD>
convert_meta (On)
</TD><TD>
If set to On, readline will convert characters with the eighth bit set to an ASCII
key sequence by stripping the eighth bit and prepending an escape character (in
effect, using escape as the meta prefix).
</TD></TR><TR><TD>
output_meta (Off)
</TD><TD>
If set to On, readline will display characters with the eighth bit set directly
rather than as a meta-prefixed escape sequence.
</TD></TR><TR><TD>
completion_query_items (100)
</TD><TD>
This determines when the user is queried about viewing the number of
possible completions generated by the
possible_completions command. It may be set to any integer value greater than or equal to
zero. If the number of possible completions is greater than or equal to the value of this variable, the user is asked whether or not
he wishes to view them; otherwise, they are simply listed on the terminal.
</TD></TR><TR><TD>
keymap (emacs)
</TD><TD>
Set the current readline keymap. The set of legal keymap names is
emacs, emacs-standard, emacs-meta, emacs-ctlx, vi,
vi-move, vi-command, and vi-insert. vi is equivalent
to vi-command; emacs is equivalent to
emacs-standard. The default value is emacs; the value of
editing_mode also affects the default keymap.
</TD></TR><TR><TD>
show_all_if_ambiguous (Off)
</TD><TD>
This alters the default behavior of the completion functions. If set to
On, words which have more than one possible completion cause the matches to be
listed immediately instead of ringing the bell.
</TD></TR><TR><TD>
expand_tilde (Off)
</TD><TD>
If set to On, tilde expansion is performed when
readline attempts word completion.
</TD></TR></TABLE>

<P>
Readline implements a facility similar in spirit to the conditional compilation features of the C preprocessor that allows
key bindings and variable settings to be performed as the result of tests. There are three parser directives used.</P>


<TABLE>

<TR><TD>
$if
</TD><TD>
The $if construct allows bindings to be made based on the editing mode,
the terminal being used, or the application using
readline. The text of the test extends to the end of the line; no characters are required to isolate it.
</TD></TR></TABLE>

<A NAME="PAGENUM-29"><P>Page 29</P></A>


<TABLE>

<TR><TD>
mode
</TD><TD>
The mode= form of the $if directive is used to test
whether readline is in emacs or vi mode. This may be used in
conjunction with the set keymap command, for instance, to set bindings in
the emacs-standard and emacs-ctlx keymaps only if
readline is starting out in emacs mode.
</TD></TR><TR><TD>
term
</TD><TD>
The term= form may be used to include terminal-specific
key bindings, perhaps to bind the key sequences output by
the terminal's function keys. The word on the right side of the
= is tested against the full name of the terminal and the portion of
the terminal name before the first _. This allows
sun to match both sun and sun_cmd, for instance.
</TD></TR><TR><TD>
application
</TD><TD>
The application construct is used to include
application_specific settings. Each program using the
readline library sets the application name, and an initialization file can test for a
particular value. This could be used to bind key sequences to
functions useful for a specific program. For instance, the
following command adds a key sequence that quotes the current or
previous word in bash:
<!-- CODE SNIP //-->
<PRE>
               $if Bash
# Quote the current or previous word
&quot;\C-xq&quot;: &quot;\eb\&quot;\ef\&quot;&quot;
$endif
</PRE>
<!-- END CODE SNIP //-->

</TD></TR><TR><TD>
$endif
</TD><TD>
This command, as shown in the preceding example, terminates an
$if command.
</TD></TR><TR><TD>
$else
</TD><TD>
Commands in this branch of the $if directive are executed if the test fails.
</TD></TR></TABLE>

<P>readline commands may be given numeric arguments, which normally act as a repeat count. Sometimes, however, it is
the sign of the argument that is significant. Passing a negative argument to a command that acts in the forward direction (such
as kill_line) causes that command to act in a backward direction. Commands whose behavior with arguments deviates
from this are noted.</P>

<P>When a command is described as killing text, the text deleted is saved for possible future retrieval (yanking). The killed
text is saved in a kill_ring. Consecutive kills cause the text to be accumulated into one unit, which can be yanked all at
once. Commands that do not kill text separate the chunks of text on the kill_ring.</P>

<P>The following is a list of the names of the commands and the default key sequences to which they are bound.</P>

<P>Commands for Moving</P>

<TABLE>

<TR><TD>
beginning_of_line (C_a)
</TD><TD>
Move to the start of the current line.
</TD></TR><TR><TD>
end_of_line (C_e)
</TD><TD>
Move to the end of the line.
</TD></TR><TR><TD>
forward_char (C_f)
</TD><TD>
Move forward a character.
</TD></TR><TR><TD>
backward_char (C_b)
</TD><TD>
Move back a character.
</TD></TR><TR><TD>
forward_word (M_f)
</TD><TD>
Move forward to the end of the next word. Words are composed of
alphanumeric characters (letters and digits).
</TD></TR><TR><TD>
backward_word (M_b)
</TD><TD>
Move back to the start of this, or the previous, word. Words are composed
of alphanumeric characters (letters and digits).
</TD></TR><TR><TD>
clear_screen (C_l)
</TD><TD>
Clear the screen leaving the current line at the top of the screen. With
an argument, refresh the current line without clearing the screen.
</TD></TR><TR><TD>
redraw_current_line
</TD><TD>
Refresh the current line. By default, this is unbound.
</TD></TR></TABLE>



<P><CENTER>
<a href="0026-0027.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0030-0030.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>