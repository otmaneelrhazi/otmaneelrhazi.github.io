<HTML>

<HEAD>
<TITLE>Linux Complete Command Reference:User Commands:EarthWeb Inc.-</TITLE>
</HEAD>
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>
</HEAD>

 -->


<!-- ISBN=0672311046 //-->
<!-- TITLE=Linux Complete Command Reference//-->
<!-- AUTHOR=Red Hat//-->
<!-- PUBLISHER=Macmillan Computer Publishing//-->
<!-- IMPRINT=Sams//-->
<!-- CHAPTER=01 //-->
<!-- PAGES=0001-0736 //-->
<!-- UNASSIGNED1 //-->
<!-- UNASSIGNED2 //-->

<P><CENTER>
<a href="0204-0205.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0208-0209.html">Next</A></CENTER></P>



<A NAME="PAGENUM-206"><P>Page 206</P></A>


<P><B>
MACROS
</B>
</P>


<P>Macros can take arguments. In a macro body, $ n where
n is between 1 and 9, will be replaced by the nth argument if
the macro is called with arguments; if there are fewer than
n arguments, it will be replaced by nothing. A word containing a
left parenthesis where the part of the word before the left parenthesis has been defined using the
define command will be recognized as a macro call with arguments; characters following the left parenthesis up to a matching right parenthesis will
be treated as comma-separated arguments; commas inside nested parentheses do not terminate an argument.
</P>

<TABLE>

<TR><TD>
sdefinenameXanythingX
</TD><TD>
This is like the
define command, but name will not be recognized if called with arguments.
</TD></TR><TR><TD>
includefile
</TD><TD>
Include the contents of file. Lines of
file beginning with .EQ or .EN will be ignored.
</TD></TR><TR><TD>
ifdefnameXanythingX
</TD><TD>
If name has been defined by
define (or has been automatically defined because
name is the output device), process anything; otherwise ignore
anything.
X can be any character not appearing in
anything.
</TD></TR></TABLE>

<P><B>
FONTS
</B>
</P>


<P>eqn normally uses at least two fonts to set an equation: an italic font for letters, and a Roman font for everything else.
The existing gfont command changes the font that is used as the italic font. By default this is
I. The font that is used as the Roman font can be changed by using the new
grfont command.
</P>

<TABLE>

<TR><TD>
grfontf
</TD><TD>
Set the Roman font to f.
</TD></TR></TABLE>


<P>The italic primitive uses the current italic font set by
gfont; the Roman primitive uses the current Roman font set by
grfont. There is also a new gbfont command, which changes the font used by the bold primitive. If you only use the Roman,
italic, and bold primitives to change fonts within an equation, you can change all the fonts used by your equations just by
using gfont, grfont, and gbfont commands.
</P>
<P>You can control which characters are treated as letters (and therefore set in italic) by using the
chartype command described earlier. A type of letter will cause a character to be set in italic type. A type of digit will cause a character to be set in
Roman type.
</P>

<P><B>
FILES
</B>
</P>


<!-- CODE SNIP //-->
<PRE>/usr/lib/groff/tmac/eqnrc     Initialization file
</PRE>
<!-- END CODE SNIP //-->

<P><B>
BUGS
</B>
</P>



<P>Inline equations will be set at the pointsize that is current at the beginning of the input line.
</P>


<P><B>
SEE ALSO
</B>
</P>


<!-- CODE SNIP //-->
<PRE>groff(1), gtroff(1), groff_font(5), The TeXbook
</PRE>
<!-- END CODE SNIP //-->

<H3><A NAME="ch01_ 85">
getlist
</A></H3>

<P>getlist&#151;Get a list from an NNTP server
</P>

<P><B>
SINOPSIS
</B>
</P>


<!-- CODE SNIP //-->
<PRE>
getlist [ _h host ][list [ pattern [ types ]]]
</PRE>
<!-- END CODE SNIP //-->

<P><B>
DESCRIPTION
</B>
</P>

<P>The getlist program obtains a list from an NNTP server and sends it to standard output.
</P>

<P>The list may be one of active, active.times,
distributions, or newsgroups. These values request the
active(5), active.times, /news/lib/distributions,
or /news/lib/newsgroups files, respectively.
</P>
<P>If the _h flag is used, then the program connects to the server on the specified host. The default is to connect to the
server specified in the inn.conf(5) file.
</P>


<A NAME="PAGENUM-207"><P>Page 207</P></A>


<P>If the list parameter is active, then the pattern and
types parameters may be used to limit the output. When
pattern is used, only active lines with groups that match according to
wildmat(3) are printed. When types is also given, only active
lines that have a fourth field starting with a character found in
types are printed.
</P>
<P>For example, the following command will obtain the one-line descriptions of all newsgroups found on
UUNET:
<!-- CODE SNIP //-->
<PRE>
getlist -h news.uu.net newsgroups
</PRE>
<!-- END CODE SNIP //-->
</P>
<P>The following line lists all groups where local postings are permitted, moderated, or aliased:
<!-- CODE SNIP //-->
<PRE>
getlist active `*' ym=
</PRE>
<!-- END CODE SNIP //-->
</P>
<P>Note that the listing files other than the active file is a common extension to the NNTP protocol and may not be
available on all servers.
</P>
<P><B>
HISTORY
</B>
</P>


<P>Written by Landon Curt Noll (&lt;chongo@toad.com&gt;) for InterNetNews.
</P>

<P><B>
SEE ALSO
</B>
</P>


<P>active(5), nnrpd(8), wildmat(3)
</P>
<H3><A NAME="ch01_ 86">
getopt
</A></H3>
<P>getopt&#151;Parse command options
</P>

<P><B>
SINOPSIS
</B>
</P>


<!-- CODE SNIP //-->
<PRE>
set _ `getopt optstring $*'
</PRE>
<!-- END CODE SNIP //-->

<P><B>
DESCRIPTION
</B>
</P>


<P>getopt is used to break up options in command lines for easy parsing by shell procedures, and to check for legal
options. optstring is a string of recognized option letters; see
getopt(3). If a letter is followed by a colon, the option is expected
to have an argument that may or may not be separated from it by whitespace. The special option
&#151;- is used to delimit the end of the options.
getopt will place &#151;- in the arguments at the end of the options, or recognize it if used explicitly. The
shell arguments ($1 $2 ...) are reset so that each option is preceded by a
_ and in its own shell argument; each option
argument is also in its own shell argument.
</P>
<P><B>
EXAMPLE
</B>
</P>

<P>The following code fragment shows how one might process the arguments for a command that can take the options
a and b, and the option o, which requires an argument:
</P>
<!-- CODE //-->
<PRE>
set &#151; `getopt abo: $*`
           if test $? != 0
           then
                   echo `Usage: ...'
                   exit 2
           fi
           for i
           do
                   case &quot;$i&quot;
                   in
                           -a|-b)
                                   flag=$i; shift;;
                           -o)
                                   oarg=$2; shift; shift;;
                           --)
                                   shift; break;;
                   esac
           done
</PRE>
<!-- END CODE //-->



<P><CENTER>
<a href="0204-0205.html">Previous</A> | <a href="../ewtoc.html">Table of Contents</A> | <a href="0208-0209.html">Next</A></CENTER></P>



</td>
</tr>
</table>
<!-- begin footer information -->




</body></html>